"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connect = void 0;
const list_js_1 = require("./list.js");
const query_js_1 = require("./query.js");
const create_js_1 = require("./create.js");
const hash_js_1 = require("./hash.js");
const siwe_js_1 = require("./siwe.js");
const tableland_calls_js_1 = require("./tableland-calls.js");
const set_controller_js_1 = require("./set-controller.js");
const get_controller_js_1 = require("./get-controller.js");
const lock_controller_js_1 = require("./lock-controller.js");
const schema_js_1 = require("./schema.js");
const structure_js_1 = require("./structure.js");
const util_js_1 = require("./util.js");
/**
 * Create client connection with Tableland, EVM, and Gateway.
 * @param options Options to control client connection.
 * @returns Promise that resolves to a Connection object.
 */
function connect(options) {
    var _a, _b, _c, _d, _e;
    const network = (_a = options.network) !== null && _a !== void 0 ? _a : "testnet";
    const chain = (_b = options.chain) !== null && _b !== void 0 ? _b : "polygon-mumbai";
    if (network === "custom" && !options.host) {
        throw new Error('`host` must be provided if using "custom" network');
    }
    if (!["testnet", "staging", "custom"].includes(network)) {
        throw new Error("unsupported network specified");
    }
    const signer = options.signer;
    const info = util_js_1.SUPPORTED_CHAINS[chain];
    if (!info && !options.chainId) {
        throw new Error("unsupported chain information. See `SUPPORTED_CHAINS` for options");
    }
    const host = (_c = options.host) !== null && _c !== void 0 ? _c : info.host;
    const chainId = (_d = options.chainId) !== null && _d !== void 0 ? _d : info.chainId;
    // We can override the contract address here for any supported network
    const contract = (_e = options.contract) !== null && _e !== void 0 ? _e : info.contract;
    // Enable specifying rpcRelay, otherwise use the SUPPORTED_CHAINS value
    const rpcRelay = typeof options.rpcRelay === "boolean" ? options.rpcRelay : info.rpcRelay;
    // If a token was provided, we cache it
    const token = options.token;
    const connectionObject = {
        token,
        signer,
        options: {
            rpcRelay,
            network,
            host,
            chain,
            chainId,
            contract,
        },
        get list() {
            return list_js_1.list;
        },
        get read() {
            return query_js_1.read;
        },
        get write() {
            return query_js_1.write;
        },
        get create() {
            return create_js_1.create;
        },
        get hash() {
            return hash_js_1.hash;
        },
        get receipt() {
            return tableland_calls_js_1.receipt;
        },
        get siwe() {
            return siwe_js_1.siwe;
        },
        get setController() {
            return set_controller_js_1.setController;
        },
        get getController() {
            return get_controller_js_1.getController;
        },
        get lockController() {
            return lock_controller_js_1.lockController;
        },
        get validate() {
            return tableland_calls_js_1.validateWriteQuery;
        },
        get waitConfirm() {
            return util_js_1.waitConfirm;
        },
        get schema() {
            return schema_js_1.schema;
        },
        get structure() {
            return structure_js_1.structure;
        },
    };
    return connectionObject;
}
exports.connect = connect;
//# sourceMappingURL=connector.js.map